Алгоритмы. Работа в VS Code с алгоритмами сортировки и поиска

1.Алгоритм сортировки выбором  — это алгоритм, который находит наименьший (или наибольший) элемент в массиве и перемещает его в начало (или конец). Процесс повторяется, пока все элементы не окажутся упорядоченными

Объяснение работы кода: на каждом шаге выбирается минимальный элемент из неотсортированной части массива 
Найденный минимальный элемент меняется местами с первым элементом в неотсортированной части 
На каждом шаге внешний цикл for (int i = 0; i < n - 1; i++) перебирает элементы слева направо, выбирая каждый раз следующий элемент из неотсортированной части массива, внутренний цикл for (int j = i + 1; j < n; j++) сравнивает оставшуюся часть массива, находя наименьший элемент справа от текущего индекса. swap(array, i, minIndex) меняет значения текущего элемента и найденного минимума.

Временная сложность: O(n^2)
Объяснение временной сложности: потому что используется два вложенных цикла, каждый из которых проходится по всему массиву. Количество операций в циклах равно n * n, где n - это длина массива. Это приводит к квадратичной сложности O(n^2) 

2.Алгоритм сортировка обменом (пузырьком) (Bubble Sort) — алгоритм, который проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном  порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

Объяснение работы кода: на каждом шаге выбирается минимальный элемент из неотсортированной части массива. Найденный минимальный элемент меняется местами с первым элементом в неотсортированной части. Процесс повторяется для оставшейся части массива. Основной цикл for (int i = 0; i < n - 1; i++)  проходит по массиву столько раз, сколько элементов минус один. После каждого полного прохода наибольший элемент гарантированно оказывается на своем месте, поэтому с каждым следующим проходом диапазон просмотра уменьшается, вложенный циклfor (int j = 0; j < n - i - 1; j++)   осуществляет непосредственное сравнение смежных элементов и меняет их местами, если порядок нарушен (текущий элемент больше последующего).
Операция осуществляется путем простого временного хранения значения одного элемента, перемещения второго элемента и восстановления первоначального элемента на новую позицию. 

Временная сложность: O(n^2)
Объяснение временной сложности: потому что используется два вложенных цикла, каждый из которых проходится по всему массиву. Количество операций в циклах равно n * n, где n - это длина массива. Это приводит к квадратичной сложности O(n^2) 


3.Алгоритм сортировка вставками - это алгоритм, который строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Объяснение работы кода: Алгоритм делит массив пополам рекурсивно до тех пор, пока не останутся подмассивы размером 1. Затем он сливает эти подмассивы, создавая большие отсортированные подмассивы. Это делается с помощью функции merge, которая объединяет два уже отсортированных подмассива.
Временная сложность: O(n log n)
Объяснение временной сложности: Массив делится пополам на каждом уровне рекурсии. Количество уровней (глубина дерева рекурсии) составляет log n. Работа на уровне: На каждом уровне рекурсии мы сливаем n элементов (все элементы массива). Функция merge для всего массива на одном уровне выполняет O(n) операций. Общая сложность: log n уровней * n элементов на уровне = O(n log n)

4.Сортировка слиянием (Merge Sort) — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке.

Объяснение работы кода: Алгоритм делит массив пополам рекурсивно до тех пор, пока не останутся подмассивы размером 1. Затем он сливает эти подмассивы, создавая большие отсортированные подмассивы. Это делается с помощью функции merge, которая объединяет два уже отсортированных подмассива.
Временная сложность: O(n log n)
Объяснение временной сложности: Массив делится пополам на каждом уровне рекурсии. Количество уровней (глубина дерева рекурсии) составляет log n. Работа на уровне: На каждом уровне рекурсии мы сливаем n элементов (все элементы массива). Функция merge для всего массива на одном уровне выполняет O(n) операций. Общая сложность: log n уровней * n элементов на уровне = O(n log n)

5.Сортировка Шелла (Shell sort) — это алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.

Объяснение работы кода: сначала массив делится на группы, каждая группа формируется таким образом, что её элементы находятся на фиксированном расстоянии друг от друга (это расстояние называется "gap"). Затем каждая группа сортируется независимо друг от друга. Постепенно "gap" уменьшается, и на последней стадии происходит обычная сортировка вставками над всем массивом.
Временная сложность: O(n log n)
Объяснение временной сложности: Внешний цикл gap уменьшается вдвое от n/2 до 1, что даёт log?(n) итераций 


6.Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.

Объяснение работы кода: Алгоритм рекурсивно выбирает опорный элемент (pivot), разделят массив на меньшие и большие, затем сортирует части. Функция swap - меняет местами два элемента. Функция partition - выбирает опорный элемент (pivot) и перераспределяет элементы так, чтобы: Слева были элементы меньше pivot, Справа - больше или равные pivot. Функция quickSort рекурсивно вызывает partition для разделения массива, сортирует левую и правую части относительно pivot. Процесс повторяется до полной сортировки массива
Временная сложность: O(n log n)
Объяснение временной сложности: В среднем случае массив делится пополам на каждом шаге (log n уровней), и на каждом уровне выполняется O(n) операций


7.Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

Объяснение работы кода: Код реализует сортировку кучей (heap sort) на Java для массива arrararr Алгоритм строит max-кучу (где родитель больше детей), затем извлекает максимумы, перемещая их в конец массива.
Временная сложность: O(n log n)
Объяснение временной сложности: выполняется n раз, каждое извлечение требует O(log n) операций для восстановления структуры кучи Итого: O(n) + O(n log n) = O(n log n)
8.Последовательный (линейный) поиск — это простой алгоритм, который поочередно проверяет каждый элемент в наборе данных, пока не будет найден искомый элемент или не будет пройден весь список.

Объяснение работы кода: Цикл for проходит по всем элементам массива последовательно, проверяя каждый элемент на совпадение с искомым значением. Условие if:Если текущий элемент массива совпадает с искомым значением, возвращается индекс этого элемента. Возврат результата:Если элемент найден, возвращает его индекс. Если элемент не найден, возвращает -1. Метод main:Демонстрирует использование метода линейного поиска. Создается массив данных. Осуществляется поиск конкретного элемента
Временная сложность: O(n)
Объяснение временной сложности: Алгоритм последовательно проверяет каждый элемент массива (цикл for от 0 до n-1). Проходит все n элементов, делая n сравнений. Это стандартный анализ линейного поиска.

9.Бинарный поиск (Binary Search) — это алгоритм для поиска элемента в отсортированном массиве.

Объяснение работы кода: Алгоритм делит диапазон пополам, сравнивает средний элемент с искомым и сужает поиск. 
Временная сложность: O(log n)
Объяснение временной сложности: Алгоритм на каждом шаге делит диапазон поиска пополам (low и high сужаются), что требует ~log?(n) итераций цикла (для n элементов). Каждая итерация — O(1) (сравнения и арифметика). Итого: O(log n)

10.Интерполирующий поиск  — это алгоритм поиска значения в упорядоченном массиве чисел, который работает быстрее бинарного поиска при равномерном распределении данных.

Объяснение работы кода: Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.
Временная сложность: O(log log n)
Объяснение временной сложности: Интерполяционный поиск использует формулу для оценки позиции элемента на основе его значения (предполагая равномерное распределение), что делает его быстрее бинарного поиска (O(log n)) в идеальных условиях — диапазон сужается экспоненциально быстрее.

11.Поиск методом Фибоначчи  — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.

Объяснение работы кода: Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с разными пропорциями.
Временная сложность: O(log n)
Объяснение временной сложности: Количество чисел Фибоначчи до n примерно равно log n. Каждая итерация цикла while уменьшает размер области поиска, используя меньшие числа Фибоначчи, что приводит к O(log n) итераций.


Контрольная работа. 

Блочная сортировка (bucket sort) — это алгоритм, который распределяет 
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
1.Объяснение работы кода: Определение максимального значения: Это нужно для равномерного распределения элементов по корзинам.
max_value = max(arr)

2.Создание списка корзин: Количество корзин определяется длиной исходного массива.
buckets_list = []  for _ in range(size):
    buckets_list.append([])

3.Распределение элементов по корзинам: Элементы распределяются равномерно среди корзин пропорционально своему значению относительно максимума.
index = int((size * arr[i]) / (max_value + 1))  
buckets_list[index].append(arr[i])

4.Сортировка каждой корзины: Для сортировки внутри корзин используется встроенная быстрая сортировка sorted(), хотя можно применить любую простую сортировку, такую как сортировка вставками.
buckets_list[i] = sorted(buckets_list[i])

5.Объединение всех корзин в итоговый отсортированный массив:
final_output = []for i in range(size):
    final_output += buckets_list[i]


Временная сложность: O(n)
Почему: так как объединяет все элементы корзин в общий список

Блинная сортировка (pancake sort) — это метод, основанный на операции 
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.
Объяснение работы кода: 
Найти максимальный элемент в неотсортированном участке массива. max_idx = arr.index(max(arr[:curr_size]))

Перевернуть участок массива таким образом, чтобы максимальный элемент стал первым элементом. reverse_subarray(arr, max_idx)

Перевернуть весь участок массива, чтобы максимальный элемент попал в конечную позицию. reverse_subarray(arr, curr_size - 1)

Временная сложность: O(n^2)

Почему: нахождения максимального элемента занимает O(N)O(N), процедура переворачивания массива на каждом этапе вызывает дополнительные накладные расходы, приводящие к общей сложности O(n^2)

Сортировка бусинами (bead sort), также известная как гравитационная 
сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл 
Диннин в 2002 году.
Объяснение работы кода: Формируем структуру бусинок: beads = [[1]*val + [0]*(cols-val) for val in arr]

Используем двумерный массив (beads), где каждая строка соответствует элементу массива, а количество единиц ("бусинок") соответствует величине числа.
Моделирование падения бусинок:
Для каждого столбца считаем сумму "падения": складываем единицы по вертикали и перераспределяем их снизу вверх.
Преобразование обратно в массив:
Полученную матриц буслов преобразовываем обратно в массив, суммируя каждую строку заново.

Временная сложность: O(n * m)
Почему: Транспонирование и суммирование по строкам/столбцам занимает O(n * m).

Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.
Объяснение работы кода: Двигаясь по массиву прыжками определенной длины, мы стараемся приблизиться к месту расположения искомого элемента. while arr[min(step, n)-1] < target

Когда попадаем на точку, где следующий элемент превышает искомое значение, возвращаемся назад и производим классический линейный поиск в ограниченном сегменте. for i in range(prev, min(step, n))


Временная сложность: O(n​)
Почему: Алгоритм первоначально определяет шаг (step), равный примерно n​. Используя этот шаг, мы делаем примерно n​ скачков по массиву, пока не достигнем элемента, большего или равного искомому.
Затем в рамках локальной зоны, ограниченной последним прыжком, проводится обычный линейный поиск. Поскольку зона поиска теперь ограничивается примерно n​ элементами, второй этап также выполняется за O(n).


Экспоненциальный поиск - это алгоритм, который сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.
Объяснение работы кода: Проверка первой позиции: if arr[0] == target

Если целевой элемент находится в самом начале массива, немедленно возвращаем его индекс.
Быстрое движение вперед: 
Используем переменную i, которую удваиваем на каждом шаге, пока не натолкнемся на элемент, который больше или равен цели либо выйдем за пределы массива.
Применение двоичного поиска: low = i // 2
    high = min(i, n-1)
    while low <= high

После обнаружения подходящей зоны запускаем обычное двоичный поиск в интервале [low, high].

Временная сложность: O(logn)
Почему: Удвоением шага: потребуется O(logn) шагов, чтобы добраться до подходящего интервала. Обычным двоичным поиском: далее потребуется ещё O(logn) для точного позиционирования.


