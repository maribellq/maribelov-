# Задание 11. Жадный алгоритм: раскраска графа 
Условие. Раскрасить вершины графа в минимальное число цветов так, чтобы соседние 
вершины имели разные цвета (жадный подход). 
Алгоритм: последовательная раскраска с выбором минимального доступного цвета. 
Язык примера: Python 
def greedy_coloring(adj_list): 
n = len(adj_list) 
colors = [-1] * n  # -1 означает, что цвет не назначен 
for v in range(n): 
#ДОПИСАТЬ: собрать используемые цвета соседей 
used = set() 
for neighbor in adj_list[v]: 
if colors[neighbor] != -1: 
used.add(colors[neighbor]) 
#ДОПИСАТЬ: назначить минимальный доступный цвет 
return colors 

Что дописать: цикл поиска минимального натурального числа, не входящего в used.

### Анализ алгоритма
Шаг 1. Основной цикл: обработка вершин по порядку
for v in range(n): Проходим по вершинам от 0 до n-1 (в фиксированном порядке, без учёта "лучшего" порядка — это делает алгоритм жадным).
Для каждой вершины v выполняем два шага: сбор цветов соседей и выбор цвета.

Шаг 2: Сбор используемых цветов соседей
used = set(): Создаём пустое множество для хранения цветов, уже назначенных соседям v.
for neighbor in adj_list[v]: Проходим по всем соседям вершины v (из списка смежности).
if colors[neighbor] != -1: Проверяем, раскрашен ли сосед (если да, его цвет уже назначен).
used.add(colors[neighbor]): Добавляем цвет соседа в used.
Результат: used содержит все уникальные цвета, используемые раскрашенными соседями v. Если соседей нет или они не раскрашены, used остаётся пустым.

Шаг 3: Назначение минимального доступного цвета
color = 0: Начинаем с минимального возможного цвета (0).
while color in used: color += 1: Цикл проверяет, есть ли color в used. Если да, увеличиваем color на 1 и повторяем, пока не найдём цвет, которого нет в used.



### Временная сложность
O(n + m), где n — число вершин, m — число рёбер.

Почему: Внешний цикл for v in range(n): O(n) итераций (по вершинам).
Внутренний цикл по соседям for neighbor in adj_list[v]: Для каждой вершины проходим по её списку смежности, суммарно O(m).
Цикл поиска цвета (while): сложность O(n + m), так как доминирует проход по рёбрам. Для графов с низкой степенью (например, деревья) это эффективно.

# Контрольный вопрос. Вариант 11. Имитация отжига 
Объясните принцип работы метаэвристики "Имитация отжига" и роль параметра температуры. 

Алгоритм имитирует физический процесс отжига металла, когда его нагревают и затем очень медленно охлаждают, чтобы получить структуру с минимальной внутренней энергией (идеальный кристалл).

Алгоритмическая аналогия:

У нас есть некоторая задача (например, коммивояжёра), где нужно найти минимум функции.

Алгоритм начинает со случайного решения и на каждом шаге генерирует соседнее, немного изменённое решение.

Ключевое правило: Если новое решение лучше, алгоритм всегда переходит на него. Если оно хуже, то он переходит на него с некоторой вероятностью.

Эта возможность делать "шаг в сторону" (в худшем направлении) позволяет алгоритму выпрыгнуть из локального минимума и продолжить поиск глобального оптимума.

### Роль параметра температуры
Температура $ T $ играет ключевую роль в балансе между исследованием (exploration) и эксплуатацией (exploitation) пространства решений:

Высокая температура (в начале): Вероятность принятия худших решений близка к 1, что позволяет алгоритму свободно исследовать пространство, преодолевая локальные оптимумы. Это аналогично нагреву металла, когда атомы хаотично движутся.

Низкая температура (в конце): Вероятность принятия худших решений стремится к 0, алгоритм становится "жадным" и фокусируется на улучшениях, сходясь к оптимуму. Это как медленное охлаждение, фиксирующее стабильную структуру.

Правильный выбор начальной температуры и скорости охлаждения критичен: слишком быстрое охлаждение может привести к локальному оптимуму, слишком медленное — к избыточным вычислениям. В практике $ T $ часто масштабируется относительно типичной величины $ \Delta E $ в задаче.
