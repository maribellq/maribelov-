1)Бинарная куча — это полное двоичное дерево, в котором все уровни, кроме последнего, полностью заполнены; последний уровень заполняется слева направо; соблюдается свойство упорядочения: значение каждого узла либо не меньше (max‑heap), либо не больше (min‑heap) значений его потомков.
В Python для создания бинарной кучи используется список+модуль heapq, где родительский элемент всегда меньше или равен дочерним. Ограничение: heapq поддерживает только минимальную кучу, для реализации максимальной кучи можно инвертировать значения. Также можно реализовать бинарную кучу в виде собственного класса. Пользователь не видит дерево: список выглядит как плоский массив, но семантически это куча. Метод heappush(list, item) — добавляет элемент в отсортированный список на позицию, соответствующую свойству кучи, heappop(list) — удаляет и возвращает минимальный элемент.
В C++ реализуется как полное бинарное дерево через std::priority_queue или std::vector. Функция push — добавляет элемент(новый элемент добавляется на последнее место в массиве, но может нарушить свойство кучи, так как новый элемент может быть больше родителя. В таком случае новый элемент «поднимается» на один уровень до тех пор, пока не будет соблюдено основное свойство кучи), pop — удаление конкретного узла — например, удаление узла из кучи.
В Java реализуется классом PriorityQueue, который использует внутренний массив. Нет прямого доступа к внутреннему массиву; все операции через API очереди. Функция add(item) / offer(item) — вставка элемента(новый элемент помещается в конец кучи, если необходимо, восстанавливается свойство кучи путём объединения и замены вновь добавленного элемента на его родительский), peek() — просмотр корня без удаления, poll() — извлечение и удаление корня(корень кучи заменяется последним элементом в куче, восстанавливается свойство кучи путём «heapifying down» из корневого узла).

2)Биноминальная куча — это структура данных, реализующая абстрактный тип «очередь с приоритетом». Она состоит из набора биномиальных деревьев, где каждое дерево соответствует определённому свойству: ключ каждой вершины не меньше ключа её родителя, и все биномиальные деревья имеют разный размер.
В стандартной библиотеке Python нет встроенной реализации биномиальной кучи. Обычно её реализуют вручную, используя классы для узлов и самой кучи BinomialHeap. Пример включает создание узлов, операции слияния деревьев и управления списком корней. Меоды: insert(key)-создаёт новый узел с заданным ключом и формирует из него биномиальное дерево степени 0; getMin()-проходит по списку корней и находит узел с минимальным ключом; merge(heap1, heap2)-объединяет два списка корней, сортируя их по возрастанию степеней.
В C++ также нет стандартной реализации в STL. Реализуется как коллекция биномиальных деревьев, требуется ручная реализация с использованием структур BinomialHeap для узлов и методов для операций над кучей. Методы: insert(int key)-создаёт узел; getMin()-проходит по списку корней, ищет минимум; extractMin()-находит и удаляет минимальный корень, детей удалённого корня добавляет в список; merge(BinomialHeap& other)-сливает два списка корней, объединяет деревья одинаковой степени; decreaseKey(BinomialNode* node, int new_key)-обновляет ключ, поднимает узел при нарушении свойства кучи. Операции реализованы как методы, работающие с указателями и перестройкой связей.
В Java стандартной реализации тоже нет. Обычно используют классы для узлов (BinomialHeapNode) и самой кучи (BinomialHeap), реализуя методы для основных операций. Управление памятью происходит через сборщик мусора, подход - объектно‑ориентированный (публичные/приватные поля). Основные операторы аналогичны Python и C++, но с синтаксисом Java: insert(int key), getMin(), extractMin(), merge(BinomialHeap other), decreaseKey(BinomialNode node, int new_key), delete(BinomialNode node)

3)Куча Фибоначчи — это структура данных для реализации очереди с приоритетом, состоящая из набора деревьев произвольной формы (не обязательно биномиальных), которые удовлетворяют свойству кучи: ключ родителя ≤ ключей детей (для min‑heap); организованы в циклический двусвязный список корней; поддерживают отложенные операции (например, объединение деревьев откладывается до необходимости).
В Python она реализуется через классы FibonacciNode и FibonacciHeap. Встроенной реализации нет — пишут вручную; управление памятью происходит через сборщик мусора Python. В алгоритме для печати ряда Фибоначчи до заданного количества элементов: цикл for выполняется ровно n раз (от 0 до n – 1) и на каждой итерации печатает текущее число Фибоначчи и обновляет переменные. В алгоритме для рекурсивного вычисления n-го числа ряда Фибоначчи: рекурсивный вызов вычисляет предыдущее и предпредыдущее числа Фибоначчи и возвращает их сумму.
В C++ реализуется через структуру Node и класс FibonacciHeap. В алгоритме: Element(T key) — создаёт узел с заданным ключом; Element(Element<T>* other) — копирующий конструктор (дублирует структуру); isEmpty() — проверяет, пуста ли куча (min == nullptr); getMin() — возвращает ключ узла min (минимум в куче); unite(FibonacciHeap<T>* heap)-слияние куч;extractMin()-извлечение минимума; decreaseKey(Element<T>* x, T k)-уменьшение ключа; deleteElement(Element<T>* x)-удаление узла. Важной деталью реализацииявляются циклические списки left/right, которые образуют кольцо: последний узел ссылается на первый - это упрощает операции вставки/удаления.
В Java куча Фибоначчи реализуется через классы FibonacciNode и FibonacciHeap. Приведенный алгоритм вычисляет n‑е число Фибоначчи по классическому рекуррентному правилу с помощью метода fibonacci(long n) - это рекурсивная функция, которая принимает на вход номер элемента ряда n и возвращает значение F(n).

4)Хеш-таблица — структура данных для хранения пар «ключ‑значение» с быстрым доступом по ключу. Основа работы: хеширование - ключ преобразуется в целое число (хеш) с помощью хеш‑функции; индексация - хеш переводится в индекс массива; разрешение коллизий - если два ключа дают один индекс, применяются методы (цепочки или открытая адресация).
В Python хеш-таблица реализуется 2 методами. 1)Хеш-таблица как класс: хэш-таблица будет представлена списком (table), и будет использоваться хэш-функция, которая вычисляет остаток от деления ASCII-значения первого символа строки ключа на размер таблицы. В этом классе есть метод __init__() для инициализации хэш-таблицы и метод _hash(), который представляет собой хэш-функцию. Метод set() добавляет пару «ключ-значение» в таблицу, а метод get() извлекает значение по его ключу, метод remove() удаляет пару «ключ-значение» из хэш-таблицы. В качестве ключей словаря должны использоваться только хэшируемые объекты — неизменяемые типы данных, такие как строки, числа, кортежи. Список не может использоваться в качестве ключа хэш-таблицы. 2)Хеш-таблица с собственной реализацией: хэш-таблица представлена массивом фиксированного размера, состоящим из бакетов (slots). Бакет содержит ключ, значение и хеш ключа. В алгоритме представлено 4 варианта разрешения коллизий: Вариант 1: простая перезапись(если ячейка пуста — создаём новую запись, иначе — обновляем значение в существующей записи); Вариант 2: цепочки через LinkedList(каждая ячейка хранит список (LinkedList) записей, и при коллизии — добавляем новую запись в список); Вариант 3: открытая адресация/линейное пробирование(если ячейка занята — переходим к следующей и используем модуль для «зацикливания» индекса); Вариант 4: двойное хеширование(использует две хеш‑функции).
В C++ для использования структур данных хеш-таблиц (хэш-карт) доступны как контейнеры из стандартной библиотеки шаблонов (STL), так и реализация вручную. 1)Алгоритм с использованием std::unordered_map — контейнер, который реализует хэш-таблицу, хранящую пары «ключ-значение». Он использует цепочечное хэширование для обработки коллизий, не сохраняет порядок элементов и позволяет определять собственные хэш-функции. 2)Алгоритм хеш-таблицы вручную на основе массива связанных списков. Он использует массив списков для хранения элементов, коллизии в нем разрешаются методом цепочек (linked list) и также предусмотрена проверка на существование ключа при вставке. Основные операторы и методы: table[key] = value — вставка/обновление, auto it = table.find(key) — поиск, value = table.at(key) — получение с проверкой, table.erase(key) или table.erase(it) — удаление, table.count(key) — проверка наличия, table.clear() — очистка. Шаблонный интерфейс: работает с любыми типами ключей и значений (если для ключа есть hash и operator==).
В Java для реализации хеш-таблицы используются классы Hashtable и HashMap. Класс Hashtable реализует хеш-таблицу, которая отображает ключи на значения. В качестве ключа и значения можно использовать любой непустой объект. Класс HashMap реализует интерфейс Map, хранит элементы в парах «ключ — значение». В HashMap хеш-таблица реализована на основе массива односвязных списков. Основные операторы и методы: table.put(key, value) — вставка/обновление, value = table.get(key) — получение(возвращает null, если ключа нет), value = table.getOrDefault(key, defaultValue) — получение с дефолтом(возвращает defaultValue, если ключа нет), boolean exists = table.containsKey(key) — проверка ключа, boolean removed = table.remove(key) — удаление, table.putAll(otherMap) — слияние.
