Алгоритмы. Работа в VS Code с алгоритмами сортировки и поиска

1.Алгоритм сортировки выбором  — это алгоритм, который находит наименьший (или наибольший) элемент в массиве и перемещает его в начало (или конец). Процесс повторяется, пока все элементы не окажутся упорядоченными

Объяснение работы кода: на каждом шаге выбирается минимальный элемент из неотсортированной части массива 
Найденный минимальный элемент меняется местами с первым элементом в неотсортированной части 
На каждом шаге внешний цикл for (int i = 0; i < n - 1; i++) перебирает элементы слева направо, выбирая каждый раз следующий элемент из неотсортированной части массива, внутренний цикл for (int j = i + 1; j < n; j++) сравнивает оставшуюся часть массива, находя наименьший элемент справа от текущего индекса. swap(array, i, minIndex) меняет значения текущего элемента и найденного минимума.

Временная сложность: O(n^2)
Объяснение временной сложности: потому что используется два вложенных цикла, каждый из которых проходится по всему массиву. Количество операций в циклах равно n * n, где n - это длина массива. Это приводит к квадратичной сложности O(n^2) 

2.Алгоритм сортировка обменом (пузырьком) (Bubble Sort) — алгоритм, который проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном  порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

Объяснение работы кода: на каждом шаге выбирается минимальный элемент из неотсортированной части массива. Найденный минимальный элемент меняется местами с первым элементом в неотсортированной части. Процесс повторяется для оставшейся части массива. Основной цикл for (int i = 0; i < n - 1; i++)  проходит по массиву столько раз, сколько элементов минус один. После каждого полного прохода наибольший элемент гарантированно оказывается на своем месте, поэтому с каждым следующим проходом диапазон просмотра уменьшается, вложенный циклfor (int j = 0; j < n - i - 1; j++)   осуществляет непосредственное сравнение смежных элементов и меняет их местами, если порядок нарушен (текущий элемент больше последующего).
Операция осуществляется путем простого временного хранения значения одного элемента, перемещения второго элемента и восстановления первоначального элемента на новую позицию. 

Временная сложность: O(n^2)
Объяснение временной сложности: потому что используется два вложенных цикла, каждый из которых проходится по всему массиву. Количество операций в циклах равно n * n, где n - это длина массива. Это приводит к квадратичной сложности O(n^2) 


3.Алгоритм сортировка вставками - это алгоритм, который строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

Объяснение работы кода: Алгоритм делит массив пополам рекурсивно до тех пор, пока не останутся подмассивы размером 1. Затем он сливает эти подмассивы, создавая большие отсортированные подмассивы. Это делается с помощью функции merge, которая объединяет два уже отсортированных подмассива.
Временная сложность: O(n log n)
Объяснение временной сложности: Массив делится пополам на каждом уровне рекурсии. Количество уровней (глубина дерева рекурсии) составляет log n. Работа на уровне: На каждом уровне рекурсии мы сливаем n элементов (все элементы массива). Функция merge для всего массива на одном уровне выполняет O(n) операций. Общая сложность: log n уровней * n элементов на уровне = O(n log n)

4.Сортировка слиянием (Merge Sort) — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке.

Объяснение работы кода: Алгоритм делит массив пополам рекурсивно до тех пор, пока не останутся подмассивы размером 1. Затем он сливает эти подмассивы, создавая большие отсортированные подмассивы. Это делается с помощью функции merge, которая объединяет два уже отсортированных подмассива.
Временная сложность: O(n log n)
Объяснение временной сложности: Массив делится пополам на каждом уровне рекурсии. Количество уровней (глубина дерева рекурсии) составляет log n. Работа на уровне: На каждом уровне рекурсии мы сливаем n элементов (все элементы массива). Функция merge для всего массива на одном уровне выполняет O(n) операций. Общая сложность: log n уровней * n элементов на уровне = O(n log n)

5.Сортировка Шелла (Shell sort) — это алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.

Объяснение работы кода: сначала массив делится на группы, каждая группа формируется таким образом, что её элементы находятся на фиксированном расстоянии друг от друга (это расстояние называется "gap"). Затем каждая группа сортируется независимо друг от друга. Постепенно "gap" уменьшается, и на последней стадии происходит обычная сортировка вставками над всем массивом.
Временная сложность: O(n log n)
Объяснение временной сложности: Внешний цикл gap уменьшается вдвое от n/2 до 1, что даёт log?(n) итераций 


6.Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.

Объяснение работы кода: Алгоритм рекурсивно выбирает опорный элемент (pivot), разделят массив на меньшие и большие, затем сортирует части. Функция swap - меняет местами два элемента. Функция partition - выбирает опорный элемент (pivot) и перераспределяет элементы так, чтобы: Слева были элементы меньше pivot, Справа - больше или равные pivot. Функция quickSort рекурсивно вызывает partition для разделения массива, сортирует левую и правую части относительно pivot. Процесс повторяется до полной сортировки массива
Временная сложность: O(n log n)
Объяснение временной сложности: В среднем случае массив делится пополам на каждом шаге (log n уровней), и на каждом уровне выполняется O(n) операций


7.Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

Объяснение работы кода: Код реализует сортировку кучей (heap sort) на Java для массива arrararr Алгоритм строит max-кучу (где родитель больше детей), затем извлекает максимумы, перемещая их в конец массива.
Временная сложность: O(n log n)
Объяснение временной сложности: выполняется n раз, каждое извлечение требует O(log n) операций для восстановления структуры кучи Итого: O(n) + O(n log n) = O(n log n)
8.Последовательный (линейный) поиск — это простой алгоритм, который поочередно проверяет каждый элемент в наборе данных, пока не будет найден искомый элемент или не будет пройден весь список.

Объяснение работы кода: Цикл for проходит по всем элементам массива последовательно, проверяя каждый элемент на совпадение с искомым значением. Условие if:Если текущий элемент массива совпадает с искомым значением, возвращается индекс этого элемента. Возврат результата:Если элемент найден, возвращает его индекс. Если элемент не найден, возвращает -1. Метод main:Демонстрирует использование метода линейного поиска. Создается массив данных. Осуществляется поиск конкретного элемента
Временная сложность: O(n)
Объяснение временной сложности: Алгоритм последовательно проверяет каждый элемент массива (цикл for от 0 до n-1). Проходит все n элементов, делая n сравнений. Это стандартный анализ линейного поиска.

9.Бинарный поиск (Binary Search) — это алгоритм для поиска элемента в отсортированном массиве.

Объяснение работы кода: Алгоритм делит диапазон пополам, сравнивает средний элемент с искомым и сужает поиск. 
Временная сложность: O(log n)
Объяснение временной сложности: Алгоритм на каждом шаге делит диапазон поиска пополам (low и high сужаются), что требует ~log?(n) итераций цикла (для n элементов). Каждая итерация — O(1) (сравнения и арифметика). Итого: O(log n)

10.Интерполирующий поиск  — это алгоритм поиска значения в упорядоченном массиве чисел, который работает быстрее бинарного поиска при равномерном распределении данных.

Объяснение работы кода: Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.
Временная сложность: O(log log n)
Объяснение временной сложности: Интерполяционный поиск использует формулу для оценки позиции элемента на основе его значения (предполагая равномерное распределение), что делает его быстрее бинарного поиска (O(log n)) в идеальных условиях — диапазон сужается экспоненциально быстрее.

11.Поиск методом Фибоначчи  — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.

Объяснение работы кода: Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с разными пропорциями.
Временная сложность: O(log n)
Объяснение временной сложности: Количество чисел Фибоначчи до n примерно равно log n. Каждая итерация цикла while уменьшает размер области поиска, используя меньшие числа Фибоначчи, что приводит к O(log n) итераций.



